import { supabase } from './client';
import type { Deck, Card } from '../types/deck';

// ==================== Deck Operations ====================

export async function getActiveDecks(userId: string) {
  const { data, error } = await supabase
    .from('decks')
    .select('*')
    .eq('user_id', userId)
    .is('deleted_at', null)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data as Deck[];
}

export async function getDeckById(deckId: string) {
  const { data, error } = await supabase
    .from('decks')
    .select('*')
    .eq('id', deckId)
    .is('deleted_at', null)
    .single();

  if (error) throw error;
  return data as Deck;
}

export async function createDeck(deck: { user_id: string; name: string; description?: string; is_public?: boolean }) {
  const { data, error } = await supabase
    .from('decks')
    .insert(deck)
    .select()
    .single();

  if (error) throw error;
  return data as Deck;
}

export async function updateDeck(deckId: string, updates: Partial<Deck>) {
  const { data, error } = await supabase
    .from('decks')
    .update(updates)
    .eq('id', deckId)
    .select()
    .single();

  if (error) throw error;
  return data as Deck;
}

export async function softDeleteDeck(deckId: string) {
  // Use PostgreSQL function to bypass RLS issues
  const { error } = await supabase.rpc('soft_delete_deck', {
    deck_id: deckId
  });

  if (error) throw error;
}

export async function restoreDeck(deckId: string) {
  const { data, error } = await supabase
    .from('decks')
    .update({ deleted_at: null })
    .eq('id', deckId)
    .select();

  if (error) throw error;
  return data;
}

export async function softDeleteDeckWithCards(deckId: string) {
  // Use PostgreSQL function to handle both deck and cards deletion
  const { error } = await supabase.rpc('soft_delete_deck', {
    deck_id: deckId
  });

  if (error) throw error;
}

// ==================== Card Operations ====================

export async function getCardsByDeckId(deckId: string) {
  const { data, error } = await supabase
    .from('cards')
    .select('*')
    .eq('deck_id', deckId)
    .is('deleted_at', null)
    .order('position', { ascending: true });

  if (error) throw error;
  return data as Card[];
}

export async function getCardById(cardId: string) {
  const { data, error } = await supabase
    .from('cards')
    .select('*')
    .eq('id', cardId)
    .is('deleted_at', null)
    .single();

  if (error) throw error;
  return data as Card;
}

export async function createCard(card: { deck_id: string; front_content: string; back_content: string; position: number }) {
  const { data, error } = await supabase
    .from('cards')
    .insert(card)
    .select()
    .single();

  if (error) throw error;
  return data as Card;
}

export async function updateCard(cardId: string, updates: Partial<Card>) {
  const { data, error } = await supabase
    .from('cards')
    .update(updates)
    .eq('id', cardId)
    .select()
    .single();

  if (error) throw error;
  return data as Card;
}

export async function softDeleteCard(cardId: string) {
  // Use PostgreSQL function to bypass RLS issues
  const { error } = await supabase.rpc('soft_delete_card', {
    card_id: cardId
  });

  if (error) throw error;
}

// ==================== Study Record Operations ====================

export async function getStudyRecord(userId: string, cardId: string) {
  const { data, error } = await supabase
    .from('study_records')
    .select('*')
    .eq('user_id', userId)
    .eq('card_id', cardId)
    .single();

  if (error && error.code !== 'PGRST116') throw error; // Ignore "not found" error
  return data;
}

export async function upsertStudyRecord(record: {
  user_id: string;
  card_id: string;
  easiness_factor?: number;
  interval?: number;
  repetitions?: number;
  next_review_date?: string;
  last_reviewed_at: string;
  last_quality: number;
  increment_total?: boolean;
  increment_correct?: boolean;
}) {
  // 先获取现有记录以计算累加统计
  const existing = await getStudyRecord(record.user_id, record.card_id);
  
  // 构建更新数据
  const updateData: Record<string, unknown> = {
    user_id: record.user_id,
    card_id: record.card_id,
    last_reviewed_at: record.last_reviewed_at,
    last_quality: record.last_quality,
    total_reviews: (existing?.total_reviews || 0) + (record.increment_total ? 1 : 0),
    correct_reviews: (existing?.correct_reviews || 0) + (record.increment_correct ? 1 : 0),
  };
  
  // 只在提供了 SM-2 相关字段时才更新它们
  if (record.easiness_factor !== undefined) {
    updateData.easiness_factor = record.easiness_factor;
  } else if (existing) {
    updateData.easiness_factor = existing.easiness_factor;
  } else {
    updateData.easiness_factor = 2.5; // 默认值
  }
  
  if (record.interval !== undefined) {
    updateData.interval = record.interval;
  } else if (existing) {
    updateData.interval = existing.interval;
  } else {
    updateData.interval = 1; // 默认值
  }
  
  if (record.repetitions !== undefined) {
    updateData.repetitions = record.repetitions;
  } else if (existing) {
    updateData.repetitions = existing.repetitions;
  } else {
    updateData.repetitions = 0; // 默认值
  }
  
  if (record.next_review_date !== undefined) {
    updateData.next_review_date = record.next_review_date;
  } else if (existing) {
    updateData.next_review_date = existing.next_review_date;
  } else {
    updateData.next_review_date = new Date().toISOString(); // 默认值
  }

  const { data, error } = await supabase
    .from('study_records')
    .upsert(updateData, { onConflict: 'user_id,card_id' })
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function getDueCards(userId: string, deckId: string) {
  const now = new Date().toISOString();
  
  // 1. 获取有学习记录且到期的卡片
  const { data: dueRecords, error: dueError } = await supabase
    .from('study_records')
    .select('*, cards!inner(*)')
    .eq('user_id', userId)
    .eq('cards.deck_id', deckId)
    .lte('next_review_date', now)
    .is('cards.deleted_at', null);

  if (dueError) throw dueError;

  // 2. 获取该卡组的所有卡片
  const { data: allCards, error: allCardsError } = await supabase
    .from('cards')
    .select('*')
    .eq('deck_id', deckId)
    .is('deleted_at', null);

  if (allCardsError) throw allCardsError;
  
  // 3. 获取此卡组中所有有学习记录的卡片ID
  const { data: allStudiedRecords, error: allStudiedError } = await supabase
    .from('study_records')
    .select('card_id, cards!inner(id)')
    .eq('user_id', userId)
    .eq('cards.deck_id', deckId);

  if (allStudiedError) throw allStudiedError;

  // 4. 找出没有学习记录的新卡片
  const studiedCardIds = new Set((allStudiedRecords || []).map((r: any) => r.card_id));
  const newCards = (allCards || []).filter((card: any) => !studiedCardIds.has(card.id));

  // 5. 将新卡片转换为与到期卡片相同的格式
  const newCardsWithRecords = newCards.map((card: any) => ({
    card_id: card.id,
    cards: card,
    user_id: userId,
  }));

  // 6. 合并到期卡片和新卡片
  return [...(dueRecords || []), ...newCardsWithRecords];
}

// ==================== Study Session Operations ====================

export async function createStudySession(session: {
  user_id: string;
  deck_id: string;
  study_mode: string;
}) {
  const { data, error } = await supabase
    .from('study_sessions')
    .insert(session)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function completeStudySession(
  sessionId: string,
  cardsStudied: number,
  durationSeconds: number
) {
  const { data, error } = await supabase
    .from('study_sessions')
    .update({
      cards_studied: cardsStudied,
      duration_seconds: durationSeconds,
      completed_at: new Date().toISOString(),
    })
    .eq('id', sessionId)
    .select()
    .single();

  if (error) throw error;
  return data;
}

// ==================== Marketplace Operations ====================

export async function getPublishedMarketplaceDecks() {
  const { data, error } = await supabase
    .from('marketplace_decks')
    .select('*, decks(*), profiles(username)')
    .eq('is_published', true)
    .is('deleted_at', null)
    .order('created_at', { ascending: false });

  if (error) throw error;
  return data;
}

export async function getMarketplaceDeckById(id: string) {
  const { data, error } = await supabase
    .from('marketplace_decks')
    .select('*, decks(*), profiles(username)')
    .eq('id', id)
    .is('deleted_at', null)
    .single();

  if (error) throw error;
  return data;
}

export async function publishDeckToMarketplace(marketplaceDeck: {
  deck_id: string;
  author_id: string;
  title: string;
  description?: string;
  price?: number;
}) {
  const { data, error } = await supabase
    .from('marketplace_decks')
    .insert({
      ...marketplaceDeck,
      is_published: true,
      published_at: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function importDeckFromMarketplace(userId: string, marketplaceDeckId: string) {
  // Get marketplace deck with cards
  const { data: marketplaceDeck, error: marketError } = await supabase
    .from('marketplace_decks')
    .select('*, decks(*, cards(*))')
    .eq('id', marketplaceDeckId)
    .single();

  if (marketError) throw marketError;
  if (!marketplaceDeck) throw new Error('Marketplace deck not found');

  const originalDeck = marketplaceDeck.decks as any;

  // Create new deck for user
  const { data: newDeck, error: deckError } = await supabase
    .from('decks')
    .insert({
      user_id: userId,
      name: marketplaceDeck.title,
      description: marketplaceDeck.description,
      is_public: false,
    })
    .select()
    .single();

  if (deckError) throw deckError;

  // Copy cards
  const cards = originalDeck.cards || [];
  if (cards.length > 0) {
    const newCards = cards.map((card: any) => ({
      deck_id: newDeck.id,
      front_content: card.front_content,
      back_content: card.back_content,
      position: card.position,
    }));

    const { error: cardsError } = await supabase
      .from('cards')
      .insert(newCards);

    if (cardsError) throw cardsError;
  }

  // Increment download count
  await supabase
    .from('marketplace_decks')
    .update({ download_count: (marketplaceDeck.download_count || 0) + 1 })
    .eq('id', marketplaceDeckId);

  return newDeck;
}

export async function checkPurchase(userId: string, marketplaceDeckId: string) {
  const { data, error } = await supabase
    .from('purchases')
    .select('*')
    .eq('user_id', userId)
    .eq('marketplace_deck_id', marketplaceDeckId)
    .single();

  if (error && error.code !== 'PGRST116') throw error;
  return data;
}

export async function createPurchase(purchase: {
  user_id: string;
  marketplace_deck_id: string;
  amount: number;
}) {
  const { data, error } = await supabase
    .from('purchases')
    .insert(purchase)
    .select()
    .single();

  if (error) throw error;
  return data;
}

/**
 * 添加或更新市场卡组评分
 */
export async function rateMarketplaceDeck(
  marketplaceDeckId: string,
  userId: string,
  rating: number
) {
  const { data, error } = await supabase
    .from('marketplace_ratings')
    .upsert({
      marketplace_deck_id: marketplaceDeckId,
      user_id: userId,
      rating,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

/**
 * 获取用户对市场卡组的评分
 */
export async function getUserRating(marketplaceDeckId: string, userId: string) {
  const { data, error } = await supabase
    .from('marketplace_ratings')
    .select('rating')
    .eq('marketplace_deck_id', marketplaceDeckId)
    .eq('user_id', userId)
    .single();

  if (error && error.code !== 'PGRST116') throw error;
  return data?.rating || null;
}

/**
 * 搜索市场卡组
 */
export async function searchMarketplaceDecks(query: string, filters?: {
  minRating?: number;
  maxPrice?: number;
  sortBy?: 'rating' | 'download_count' | 'created_at';
}) {
  let queryBuilder = supabase
    .from('marketplace_decks')
    .select('*, profiles(username)')
    .eq('is_published', true)
    .is('deleted_at', null);

  if (query) {
    queryBuilder = queryBuilder.or(`title.ilike.%${query}%,description.ilike.%${query}%`);
  }

  if (filters?.minRating) {
    queryBuilder = queryBuilder.gte('rating', filters.minRating);
  }

  if (filters?.maxPrice !== undefined) {
    queryBuilder = queryBuilder.lte('price', filters.maxPrice);
  }

  const sortBy = filters?.sortBy || 'created_at';
  const sortOrder = sortBy === 'rating' || sortBy === 'download_count' ? 'desc' : 'desc';
  queryBuilder = queryBuilder.order(sortBy, { ascending: sortOrder === 'asc' });

  const { data, error } = await queryBuilder;

  if (error) throw error;
  return data || [];
}

// ==================== Study Statistics Operations ====================

/**
 * 获取卡组的学习统计
 * @param userId 用户ID
 * @param deckId 卡组ID
 * @returns 卡组学习统计信息
 */
export async function getDeckStudyStats(userId: string, deckId: string) {
  // 先获取卡组中的所有卡片
  const { data: cards, error: cardsError } = await supabase
    .from('cards')
    .select('id')
    .eq('deck_id', deckId)
    .is('deleted_at', null);

  if (cardsError) throw cardsError;
  
  const totalCards = cards?.length || 0;
  
  if (totalCards === 0) {
    return {
      totalCards: 0,
      studiedCards: 0,
      totalReviews: 0,
      correctReviews: 0,
      averageEasiness: 2.5,
      successRate: 0,
    };
  }
  
  // 获取学习记录
  const { data: records, error: recordsError } = await supabase
    .from('study_records')
    .select('*')
    .eq('user_id', userId)
    .in('card_id', cards.map(c => c.id));

  if (recordsError) throw recordsError;
  
  // 计算统计信息
  const stats = {
    totalCards,
    studiedCards: records?.filter(r => r.total_reviews > 0).length || 0,
    totalReviews: records?.reduce((sum, r) => sum + (r.total_reviews || 0), 0) || 0,
    correctReviews: records?.reduce((sum, r) => sum + (r.correct_reviews || 0), 0) || 0,
    averageEasiness: records && records.length > 0 
      ? records.reduce((sum, r) => sum + r.easiness_factor, 0) / records.length 
      : 2.5,
    successRate: 0,
  };
  
  if (stats.totalReviews > 0) {
    stats.successRate = (stats.correctReviews / stats.totalReviews) * 100;
  }
  
  return stats;
}

/**
 * 获取用户的总体学习统计
 * @param userId 用户ID
 * @returns 用户总体学习统计信息
 */
export async function getUserStudyStats(userId: string) {
  const { data, error } = await supabase
    .from('study_records')
    .select('*')
    .eq('user_id', userId);

  if (error) throw error;
  
  return {
    totalCards: data.length,
    studiedCards: data.filter(r => r.total_reviews > 0).length,
    totalReviews: data.reduce((sum, r) => sum + (r.total_reviews || 0), 0),
    correctReviews: data.reduce((sum, r) => sum + (r.correct_reviews || 0), 0),
    successRate: data.reduce((sum, r) => sum + (r.total_reviews || 0), 0) > 0
      ? (data.reduce((sum, r) => sum + (r.correct_reviews || 0), 0) / 
         data.reduce((sum, r) => sum + (r.total_reviews || 0), 0)) * 100
      : 0,
  };
}

/**
 * 获取用户最近的学习会话
 * @param userId 用户ID
 * @param limit 返回的最大记录数
 * @returns 学习会话列表
 */
export async function getRecentStudySessions(userId: string, limit = 10) {
  const { data, error } = await supabase
    .from('study_sessions')
    .select('*, decks(name)')
    .eq('user_id', userId)
    .order('started_at', { ascending: false })
    .limit(limit);

  if (error) throw error;
  return data;
}

/**
 * 获取时间范围内的学习趋势数据
 * @param userId 用户ID
 * @param startDate 开始日期
 * @param endDate 结束日期
 * @returns 按日期分组的学习统计数据
 */
export async function getStudyTrendData(userId: string, startDate: Date, endDate: Date) {
  const { data, error } = await supabase
    .from('study_sessions')
    .select('started_at, cards_studied')
    .eq('user_id', userId)
    .gte('started_at', startDate.toISOString())
    .lte('started_at', endDate.toISOString())
    .order('started_at', { ascending: true });

  if (error) throw error;

  // 按日期分组统计数据
  const dailyData = new Map<string, { date: string; cards: number; sessions: number }>();
  
  (data || []).forEach(session => {
    const date = new Date(session.started_at).toISOString().split('T')[0];
    const existing = dailyData.get(date) || { date, cards: 0, sessions: 0 };
    existing.cards += session.cards_studied || 0;
    existing.sessions += 1;
    dailyData.set(date, existing);
  });

  return Array.from(dailyData.values());
}

/**
 * 获取时间范围内的成功率趋势数据
 * @param userId 用户ID
 * @param startDate 开始日期
 * @param endDate 结束日期
 * @returns 按日期分组的成功率数据
 */
export async function getSuccessRateTrendData(userId: string, startDate: Date, endDate: Date) {
  const { data, error } = await supabase
    .from('study_records')
    .select('updated_at, total_reviews, correct_reviews')
    .eq('user_id', userId)
    .gte('updated_at', startDate.toISOString())
    .lte('updated_at', endDate.toISOString())
    .order('updated_at', { ascending: true });

  if (error) throw error;

  // 按日期分组统计数据
  const dailyData = new Map<string, { date: string; total: number; correct: number }>();
  
  (data || []).forEach(record => {
    const date = new Date(record.updated_at).toISOString().split('T')[0];
    const existing = dailyData.get(date) || { date, total: 0, correct: 0 };
    existing.total += record.total_reviews || 0;
    existing.correct += record.correct_reviews || 0;
    dailyData.set(date, existing);
  });

  return Array.from(dailyData.values()).map(item => ({
    date: item.date,
    successRate: item.total > 0 ? (item.correct / item.total) * 100 : 0,
  }));
}

/**
 * 获取学习活跃度数据（用于热力图）
 * @param userId 用户ID
 * @param startDate 开始日期
 * @param endDate 结束日期
 * @returns 按日期和星期分组的学习活跃度
 */
export async function getStudyActivityData(userId: string, startDate: Date, endDate: Date) {
  const { data, error } = await supabase
    .from('study_sessions')
    .select('started_at, cards_studied')
    .eq('user_id', userId)
    .gte('started_at', startDate.toISOString())
    .lte('started_at', endDate.toISOString());

  if (error) throw error;

  // 按日期分组，计算每天的学习卡片数
  const activityMap = new Map<string, number>();
  
  (data || []).forEach(session => {
    const date = new Date(session.started_at).toISOString().split('T')[0];
    const existing = activityMap.get(date) || 0;
    activityMap.set(date, existing + (session.cards_studied || 0));
  });

  return Array.from(activityMap.entries()).map(([date, count]) => ({
    date,
    count,
  }));
}

// ==================== Search Operations ====================

/**
 * 搜索卡组
 * @param userId 用户ID
 * @param query 搜索关键词
 * @returns 匹配的卡组列表
 */
export async function searchDecks(userId: string, query: string) {
  const { data, error } = await supabase
    .from('decks')
    .select('id, name, description, created_at')
    .eq('user_id', userId)
    .is('deleted_at', null)
    .or(`name.ilike.%${query}%,description.ilike.%${query}%`)
    .limit(10);
  
  if (error) throw error;
  
  // 获取每个卡组的卡片数量
  const decksWithCount = await Promise.all(
    (data || []).map(async (deck) => {
      const { count } = await supabase
        .from('cards')
        .select('*', { count: 'exact', head: true })
        .eq('deck_id', deck.id)
        .is('deleted_at', null);
      
      return {
        ...deck,
        cardCount: count || 0,
      };
    })
  );
  
  return decksWithCount;
}

/**
 * 搜索卡片
 * @param userId 用户ID
 * @param query 搜索关键词
 * @returns 匹配的卡片列表
 */
export async function searchCards(userId: string, query: string) {
  const { data, error } = await supabase
    .from('cards')
    .select('*, decks!inner(id, name, user_id)')
    .eq('decks.user_id', userId)
    .is('deleted_at', null)
    .is('decks.deleted_at', null)
    .or(`front_content.ilike.%${query}%,back_content.ilike.%${query}%`)
    .limit(10);
  
  if (error) throw error;
  return data || [];
}

// ==================== Tag Operations ====================

/**
 * 创建标签
 */
export async function createTag(tag: { user_id: string; name: string; color: string }) {
  const { data, error } = await supabase
    .from('tags')
    .insert(tag)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

/**
 * 获取用户的所有标签
 */
export async function getUserTags(userId: string) {
  const { data, error } = await supabase
    .from('tags')
    .select('*')
    .eq('user_id', userId)
    .is('deleted_at', null)
    .order('name');
  
  if (error) throw error;
  return data;
}

/**
 * 更新标签
 */
export async function updateTag(tagId: string, updates: { name?: string; color?: string }) {
  const { data, error } = await supabase
    .from('tags')
    .update(updates)
    .eq('id', tagId)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

/**
 * 软删除标签
 */
export async function softDeleteTag(tagId: string) {
  const { error } = await supabase
    .from('tags')
    .update({ deleted_at: new Date().toISOString() })
    .eq('id', tagId);
  
  if (error) throw error;
}

// ==================== Card Tag Operations ====================

/**
 * 为卡片添加标签
 */
export async function addTagToCard(cardId: string, tagId: string) {
  const { data, error } = await supabase
    .from('card_tags')
    .insert({ card_id: cardId, tag_id: tagId })
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

/**
 * 从卡片移除标签
 */
export async function removeTagFromCard(cardId: string, tagId: string) {
  const { error } = await supabase
    .from('card_tags')
    .delete()
    .eq('card_id', cardId)
    .eq('tag_id', tagId);
  
  if (error) throw error;
}

/**
 * 获取卡片的所有标签
 */
export async function getCardTags(cardId: string) {
  const { data, error } = await supabase
    .from('card_tags')
    .select('*, tags(*)')
    .eq('card_id', cardId);
  
  if (error) throw error;
  return data;
}

/**
 * 获取卡组中带标签的所有卡片
 */
export async function getCardsWithTags(deckId: string) {
  const { data, error } = await supabase
    .from('cards')
    .select('*, card_tags(*, tags(*))')
    .eq('deck_id', deckId)
    .is('deleted_at', null)
    .order('position');
  
  if (error) throw error;
  return data;
}

/**
 * 按标签筛选卡片
 */
export async function getCardsByTag(deckId: string, tagId: string) {
  const { data, error } = await supabase
    .from('cards')
    .select('*, card_tags!inner(*)')
    .eq('deck_id', deckId)
    .eq('card_tags.tag_id', tagId)
    .is('deleted_at', null)
    .order('position');
  
  if (error) throw error;
  return data;
}

